<!--
  Programming Assignment 5 Write-up
  Version: 0.2b
  Date Changed: 11/27/13
  Last Edited By: Menghui Wang
  
  Change Log:
    11/26/13 - First Version Release (0.1) for review
    11/27/13 - Modifying the document to use LinkedList for chaining instead of ArrayList
    12/01/13 - Change HashTable to SimpleHashMap
  
-->
<content for="title">CS 367, Programming Assignment 5</content>

<content for="top">
<h2>CS 367 Programming Assignment 5</h2>
<font size="+1" color="#990000"><b>DUE by 10:00 PM on Sunday, December 15th</b><br></font>

<br>
<a href="#Announcements">P5 Announcements</a> |
<a href="#Overview">Overview</a> |
<a href="#Specifications">Specifications</a> |
<a href="#Steps">Steps</a> |
<a href="#Submission">Submission</a>
</content>


<content for="main">

<div class="announcements">

<a name="Announcements"></a>
<h2>P5 Announcements</h2>

<p>Corrections, clarifications, and other announcements regarding this programming assignment will be found below.</p>

<ul>
  <li><b>12/2/2013:</b> Program assigned.</li>
</ul>


</div>
<div>

<a name="Overview"></a>
<h2>Overview</h2>

<h3>Description</h3>
<p>
In this assignment you will implement a hashtable-based generic map, and use that hash map to compute
the most frequent words in a text file.
The program will then print out a list of the top 11 most frequently used words in the file.  
</p>

<p>
A brute force approach to the word counter task without a sophisticated data structure would take quadratic time.
With the help of a hash map, the main program can maintain a map from words to their number of occurrences efficiently.
The overall complexity can be reduced to linear under ideal hash functions.
This made the program possible to work on very large files.
</p>
  
<h3>Goals</h3>

  <p>The goals of this assignment are to:</p>
  <ul>
    <li>Gain experience with hashing.</li>
    <li>Gain experience resizing a data structure.</li>
    <li>Gain experience using a data structure to solve a problem efficiently.</li>
  </ul>


</div>
<div>

<a name="Specifications"></a>
<h2>Specifications</h2>

<h3>The <tt>SimpleHashMap&ltK, V&gt</tt> Class</h3>
<p>
This class implements a generic map based on hashtables using chaining
as its collision resolution.
</p>

<p>
A map is a data structure that creates a key-value mapping. Keys are
<i>unique</i> in the map. That is, there cannot be more than one value associated
with a same key. However, two keys can map to a same value.
</p>

<p>
The <tt>SimpleHashMap</tt> class takes two generic parameters, <tt>K</tt> and
<tt>V</tt>, standing for the types of keys and values respectively. Items
are stored in a hashtable. Hash values are computed from the
<tt>hashCode()</tt> method of the <tt>K</tt> type objects.
</p>

<p>
Chains for each bucket are implemented using Java's <tt>LinkedList</tt>. When
a hashtable is created, its initial table size and maximum load factor is
set to <tt>11</tt> and <tt>0.75</tt>. The hashtable can hold arbitrarily
many key-value pairs and resizes itself whenever it reaches its
maximum load factor.
</p>

<p>
<tt>null</tt> values are <i>not</i> allowed in <tt>SimpleHashMap</tt>. You can assume that
<tt>equals()</tt> and <tt>hashCode()</tt> on <tt>K</tt> are well defined.
That is, if for two non-<tt>null</tt> keys <tt>k1</tt> and <tt>k2</tt>,
if <tt>k1.equals(k2)</tt>, then <tt>k1.hashCode() == k2.hashCode()</tt>.
Do not assume in the other direction.
</p>

<p>The <tt><a href="assignments/p5/javadocs/SimpleHashMap.html">javadoc</a></tt> for the <tt>SimpleHashMap</tt> class
gives information about the methods you need to implement. You will implement each method as described in the javadocs.
Read it carefully before coding.
A skeleton class is provided for you; see <tt><a href="assignments/p5/files/SimpleHashMap.java">SimpleHashMap.java</a></tt>.
Additionally, your <tt>SimpleHashMap</tt> must <b>not</b> use Java's hashtable-based data structures.

<p>In order to implement the generic map, you will use an auxiliary <tt>Entry&ltK, V&gt</tt> class to encapsulate the key and value in one object.
The skeleton of this class has been defined for you in <tt>SimpleHashMap</tt>.
In addition, when implementing the <tt>entries</tt> method that returns a list of all mappings in the map, you will
make use of this class.
<p>

<p>The constructor of the class initializes the hashtable with initial capacity 11 and maximum <i>load factor</i> 0.75.
The load factor is defined to be the number of items in the hashtable 
divided by the capacity of the hashtable.
The maximum load factor is a measure of how full the hashtable is allowed to get before it will be resized.
For example, a maximum load factor of 0.75 means that, under ideal hashing (when
there are no collisions), the hashtable is allowed to get up to 80% full before it will be resized.</p>

<p>The index you will use to determine where to store an entry will be very simple.
You will call the <tt>hashCode()</tt> method on the key of the mapping you need to insert or
lookup and modulo this value by the table size (to make sure it is a valid index).
One potential issue is that <tt>hashCode()</tt> can return a negative
value.
As a result of Java's convention on negative modulos, when you take a modulo of a negative value, the result is a 
negative value.
A recommended way to get around this is to check the value of 
<tt>hashCode()</tt> modulo table size, and if it is negative, simply add table size to
the result.
This will give you a positive value between 0 and <i>table size-1</i>.
</p>

<p>
The <tt>entries</tt> method returns a list of all mappings in this map.
Note that the return value of this method is <tt>List&ltSimpleHashMap.Entry&ltK, V&gt&gt</tt>,
which is a Java List carrying all the entries in the map.
Since <tt>List</tt> is an interface instead of a class, it cannot be instantiated.
However you can instantiate any class that implements the <tt>List</tt> interface such as <tt>ArrayList</tt> and <tt>LinkedList</tt> and return it.
</p>

<p>
This method iterates through the hashtable and collect all entries into a new list.
Remember that with naive implementations full iteration over a hashtable can be slow as it has to walk through all of the buckets, among which many may be empty.
Although in fact fast iteration for hashtables can be done in linear time with a combination of an auxiliary linear list, this is not required by this assignment.
</p>

<p>Some useful tips your <tt>SimpleHashMap</tt> class:</p>
<ul>
    <li>Duplicated keys are <i>not</i> allowed in a map. If the user tries to associate a value with a key that is already
    in the map, the old value should be replaced.</li>
    <li><tt>null</tt> values are <i>not</i> allowed in <tt>SimpleHashMap</tt>. Both keys and values should be non-<tt>null</tt>.
    All methods should throw <tt>NullPointerException</tt> whenever a <tt>null</tt> parameter is detected.</li>
    <li>Your code can (and should) use methods from the <tt>Object</tt> class, such as
        <tt>equals</tt> and <tt>hashCode</tt>. </li>
        <li>You can assume <tt>hashCode</tt> on keys are defined properly. That is, if two keys are equal, their <tt>hashCode</tt>s must also be equal. However for two keys with the same <tt>hashCode</tt>s, the keys may not equal.
        Therefore, test equality on keys using <tt>equals</tt> rather than using <tt>hashCode</tt>.</li>
    <li>The correctness of your <tt>SimpleHashMap</tt> should <i>not</i> rely on a good hash function. For example, suppose some class has a very bad <tt>hashCode</tt> method that always returns 0 (note that this is still a legal way to define <tt>hashCode</tt>). Your <tt>SimpleHashMap</tt> should still work correctly with that class as the key type, though the performance could be pretty bad.</li>
    <li>You don't ever need to shrink your hashtable.</li>
</ul>

<p>The 
<a href="http://docs.oracle.com/javase/6/docs/api/java/util/LinkedList.html"><tt>LinkedList</tt>
javadoc</a> lists (and describes) all the <tt>LinkedList</tt> methods.  You can use
any of the <tt>LinkedList</tt> methods, so be sure to 
look over the documentation carefully to determine which <tt>LinkedList</tt> methods
you will want to use in this program.</p>


<h3>The <tt>WordFrequencyMain</tt> Class</h3>

<p>The WordFrequencyMain class will contain the <tt>main()</tt> function that is the entry point for your 
application. This will be where the file is read in and words are counted.</p>

<p>
The main method of this program works as follows.
It will take in a command line argument <tt>args[0]</tt> (rather than keyboard input!) containing the file name.
It then reads the file word by word and maintaining a <tt>SimpleHashMap</tt> from each word to its count of occurrences.
Finally, it outputs a list of top 11 frequent words in the file in the order of their count of occurrences, with most frequent word first.
In case there is a tie, the word with smaller alphabetical order comes first.
If there are no more than 11 words in the file, all words should be printed.
</p>

<p>A skeleton class is provided for you; see <tt><a href="assignments/p5/files/WordFrequencyMain.java">WordFrequencyMain.java</a></tt>. The next sections will explain in detail the input and output requirements and restrictions, as well as sample cases.
</p>

<p>
You can either design your own hash function or use Java's built-in hash functions.
The running time of your program should be linear in the length of the input file under the assumption that the hash function produces no collision.
Test your program against all sample cases provided below, and make sure they produce exactly the same results as sample outputs.
All cases are designed to be computed within less than 1 second on a modern computer, so if it takes your program far more time than that, it's an indication that you have done something wrong.
</p>

<h3>Input Requirements</h3>
<p>
The program should take a single command line argument which indicates the file name.
There would always be exactly one such argument, and the file is guaranteed to be accessible.
</p>

<p>
The file contains only lower case letters and separators, i.e. spaces and newlines ('\n').
There won't be two consecutive separators.
A <i>word</i> is defined to be a sequence of letters separated by separators.
The file always contains at least one word.
</p>

<h3>Output Requirements</h3>
<p>
The program should print to standard output the top 11 most frequent word in the file, one word each line, in the order of their counts of occurrences, with most frequent word first.
If two words have the same number of occurrences, the one alphabetically smaller should come first.
If there are less than 11 distinct words in the file, output all the words in the order specified above.
</p>

<h3>Sample Cases</h3>
<ol>
    <li><a href="assignments/p5/files/sampleFile1.txt">sampleFile1.txt</a> and <a href="assignments/p5/files/sampleOutput1.txt">sampleOutput1.txt</a>.
        In this sample case, "it", "was", "the", "of" occurred the same number of times, so their places are determined by their alphabetical orders.
    </li>
    <li><a href="assignments/p5/files/sampleFile2.txt">sampleFile2.txt</a> and <a href="assignments/p5/files/sampleOutput2.txt">sampleOutput2.txt</a>.
        This sample case contains only one word. So the output is that word.
    </li>
    <li><a href="assignments/p5/files/sampleFile3.txt">sampleFile3.txt</a> and <a href="assignments/p5/files/sampleOutput3.txt">sampleOutput3.txt</a>.
        This is a big text file containing 1m words.
        Since the number of the distinct words is very small (only "a" and "b"), the processing time of this case should be pretty small (less than 1 second).
    </li>
    <li><a href="assignments/p5/files/sampleFile4.txt">sampleFile4.txt</a> and <a href="assignments/p5/files/sampleOutput4.txt">sampleOutput4.txt</a>.
        A text file containing 100k random words.
    </li>
</ol>

</div>
<div>

<a name="Steps"></a>
<h2>Steps</h2>

<p>After you have read this program page and given thought to the problem
we suggest the following steps:</p>

<ol>
  <li>If you are working with a partner, review the
      <a href="?r=coursework#pp">rules for pair programming</a>.</li>
  <li>Review these <a href="?r=styleGuide">style</a> and
      <a href="?r=commentingGuide">commenting</a> standards that are used to
      evaluate your program.</li>
  <li>You may use the Java development environment of your choice in CS 367.
      <em><b>However, all programs must compile and run on the lab computers
      for grading.</b></em> If you are going to use the CS
      <a href="?r=computerLabs">lab computers</a>, we recommend that you use
      Eclipse. You may want to review the
      <a href="http://pages.cs.wisc.edu/%7Ecs302/labs/EclipseTutorial/" target="_tab">Eclipse
      tutorial</a> to learn the basics. Note that on the Linux lab computers,
      you should enter "<tt>eclipse&amp;</tt>" at the prompt instead of what
      is described in the tutorial.</li>
  <li>Download the following files to your programming assignment 5	 
directory:
      <ul>
      <li><a href="assignments/p5/files/WordFrequencyMain.java"><tt>WordFrequencyMain.java</tt></a></li>
      <li><a href="assignments/p5/files/SimpleHashMap.java"><tt>SimpleHashMap.java</tt></a></li> 
      </ul>
      <br></li>
      Do <b>not</b> use a package name for your program.
  </li>
  <li>Implement and thoroughly test your <tt>SimpleHashMap</tt> class.</li>
  <li>Implement and thoroughly test your <tt>WordFrequencyMain</tt> class.</li>
  <li>If you are not using the lab computers to develop your program, make
      sure you compile and run your program to ensure that it works on the
      Linux lab computers. You can compile your Java source using <tt>javac</tt>
      in a terminal window as in this example: <dir><tt>javac *.java</tt></dir>
      and the run your program using <tt>java</tt> as in:

      <dir><tt>java WordFrequencyMain inputFile</tt></dir>.
</li>
  <li>Make sure your program passes all sample cases.</li>

  <li>Submit your work for grading.</li>
</ol>


</div>
<div>

<a name="Submission"></a>
<h2>Submitting Your Work</h2>

<p>Make sure your code follows the <a href="?r=styleGuide">style</a> and
<a href="?r=commentingGuide">commenting</a> standards used in CS 302 and
CS 367.</p>

<p><a href="?r=coursework#Handin">Electronically submit</a> the following file
to your <b><tt>in</tt></b> "handin" directory by the due date and time (or
refer to the <a href="?r=coursework#Late">late policy</a>):</p>

<ul>
      <li>"<tt>WordFrequencyMain.java</tt>" containing your <tt>WordFrequencyMain</tt> class,</li>
      <li>"<tt>SimpleHashMap.java</tt>" containing your modified <tt>SimpleHashMap</tt> class,</li>
      <li>"<tt>*.java</tt>" only if you implemented additional classes for your program.</li>
  <br />
  <li>If you are working with a partner, only one partner submits the program 
      files, but <b>both partners must submit to his/her own hand-in directory
      a completed
      <a href="assignments/README.txt"><tt>README.txt</tt></a> file.</b>
      Students working in pairs must follow the 
      <a href="?r=coursework#pp">rules for pair programming</a>.</li>
</ul>

<p><em><b>Please turn in only the files named above.</b></em> Extra files 
clutter up the "handin" directories.</p>

</div>
</content>
